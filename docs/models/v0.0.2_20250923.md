# GEPP Platform Database Architecture - Materials Restructure v0.0.2 - September 23, 2025

## Executive Summary
This document describes the comprehensive restructuring of the materials system in the GEPP Platform, introducing a sophisticated tag-based material management system while maintaining backward compatibility with existing structures.

## Materials System Restructure v0.0.2

### Overview
The new materials system introduces a four-tier architecture that supports flexible material categorization through tags and tag groups, while maintaining compatibility with existing category and main material classifications.

### New Architecture

#### Four-Tier Material Hierarchy
```
MaterialCategory (existing)
‚îú‚îÄ‚îÄ MainMaterial (existing)
‚îÇ   ‚îî‚îÄ‚îÄ Material (enhanced)
‚îî‚îÄ‚îÄ BaseMaterial (new)
    ‚îú‚îÄ‚îÄ MaterialTagGroup (new)
    ‚îÇ   ‚îî‚îÄ‚îÄ MaterialTag (new)
    ‚îî‚îÄ‚îÄ Material (enhanced with tags)
```

## New Database Tables

### 1. Material Tags (`material_tags`)
**Purpose**: Store individual waste material condition tags that can be organization-specific or global.

```sql
CREATE TABLE material_tags (
    id BIGSERIAL PRIMARY KEY,
    is_active BOOLEAN NOT NULL DEFAULT true,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    color VARCHAR(7) NOT NULL DEFAULT '#808080',
    is_global BOOLEAN NOT NULL DEFAULT false,
    organization_id BIGINT REFERENCES organizations(id) ON DELETE CASCADE,
    created_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    deleted_date TIMESTAMP WITH TIME ZONE NULL
);
```

**Key Features:**
- **Organization Scoped**: Tags can be global or organization-specific
- **Visual Representation**: Color coding for UI display
- **Constraint Logic**: Global tags have null organization_id, org-specific tags require organization_id

**Examples of Tags:**
- Colors: 'red', 'blue', 'white', 'clear'
- Quality: 'good', 'poor', 'contaminated'
- Processing: 'baled', 'loose', 'shredded'
- Condition: 'clean', 'dirty', 'mixed'

### 2. Material Tag Groups (`material_tag_groups`)
**Purpose**: Group similar category material tags for logical organization.

```sql
CREATE TABLE material_tag_groups (
    id BIGSERIAL PRIMARY KEY,
    is_active BOOLEAN NOT NULL DEFAULT true,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    color VARCHAR(7) NOT NULL DEFAULT '#808080',
    is_global BOOLEAN NOT NULL DEFAULT false,
    tags BIGINT[] NOT NULL DEFAULT '{}',
    organization_id BIGINT REFERENCES organizations(id) ON DELETE CASCADE,
    created_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    deleted_date TIMESTAMP WITH TIME ZONE NULL
);
```

**Key Features:**
- **Tag Grouping**: Array of material_tag IDs for logical categorization
- **Array Storage**: PostgreSQL array type with GIN indexing for performance
- **Organization Scoped**: Like tags, can be global or organization-specific

**Examples of Tag Groups:**
- "Colors": [red_tag_id, blue_tag_id, white_tag_id, clear_tag_id]
- "Quality Levels": [good_tag_id, fair_tag_id, poor_tag_id]
- "Processing States": [baled_tag_id, loose_tag_id, shredded_tag_id]

### 3. Base Materials (`base_materials`)
**Purpose**: Fundamental material types that can be combined with material tags to create specific materials.

```sql
CREATE TABLE base_materials (
    id BIGSERIAL PRIMARY KEY,
    is_active BOOLEAN NOT NULL DEFAULT true,
    created_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    deleted_date TIMESTAMP WITH TIME ZONE NULL,
    category_id BIGINT REFERENCES material_categories(id) ON DELETE SET NULL,
    main_material_id BIGINT REFERENCES main_materials(id) ON DELETE SET NULL,
    tag_groups BIGINT[] NOT NULL DEFAULT '{}',
    unit_name_th VARCHAR(255) NOT NULL,
    unit_name_en VARCHAR(255) NOT NULL,
    unit_weight DECIMAL(10,3) NOT NULL DEFAULT 1,
    color VARCHAR(7) NOT NULL DEFAULT '#808080',
    calc_ghg DECIMAL(10,3) NOT NULL DEFAULT 0,
    name_th VARCHAR(255) NOT NULL,
    name_en VARCHAR(255) NOT NULL
);
```

**Key Features:**
- **Hybrid Structure**: Links to both existing categories/main materials and new tag groups
- **Template System**: Defines which tag groups can be applied to create specific materials
- **Environmental Intelligence**: Built-in GHG calculation factors
- **Multi-language Support**: Thai and English naming

**Example Base Material:**
- Name: "PET Plastic"
- Applicable Tag Groups: [colors_group_id, quality_group_id, processing_group_id]
- When combined with tags: "Red Good Quality Baled PET Plastic"

## Enhanced Materials Table

### Updated Structure
The materials table has been enhanced to support both the legacy structure and the new tag-based system:

```sql
-- Enhanced materials table structure
ALTER TABLE materials
ADD COLUMN IF NOT EXISTS base_material_id BIGINT REFERENCES base_materials(id) ON DELETE SET NULL,
ADD COLUMN IF NOT EXISTS tags JSONB NOT NULL DEFAULT '[]';
```

**Complete Column Structure:**
```python
class Material(Base, BaseModel):
    __tablename__ = 'materials'

    # Legacy structure (maintained for backward compatibility)
    category_id = Column(BigInteger, ForeignKey('material_categories.id'), nullable=True)
    main_material_id = Column(BigInteger, ForeignKey('main_materials.id'), nullable=True)

    # New tag-based structure
    base_material_id = Column(BigInteger, ForeignKey('base_materials.id'), nullable=True)
    tags = Column(JSONB, nullable=False, default=[])  # [(tag_group_id, tag_id), ...]

    # Material properties
    unit_name_th = Column(String(255), nullable=False)
    unit_name_en = Column(String(255), nullable=False)
    unit_weight = Column(DECIMAL(10, 3), nullable=False, default=1)
    color = Column(String(7), nullable=False, default='#808080')
    calc_ghg = Column(DECIMAL(10, 3), nullable=False, default=0)
    name_th = Column(String(255), nullable=False)
    name_en = Column(String(255), nullable=False)

    # Relationships
    category = relationship("MaterialCategory")
    main_material = relationship("MainMaterial")
    base_material = relationship("BaseMaterial")
```

### Tag Mapping System
The `tags` JSONB column stores an array of tuples mapping tag groups to specific tags:

```json
[
  [4, 1],  // Color group -> Red tag
  [3, 8],  // Quality group -> Good tag
  [1, 2]   // Processing group -> Baled tag
]
```

**Business Logic:**
- Each tuple represents: `(material_tag_group_id, material_tag_id)`
- Validates that the specified tag belongs to the specified group
- Enables complex material condition specifications
- Supports dynamic material creation through tag combinations

## Migration Strategy

### Backward Compatibility Approach
The migration maintains full backward compatibility by:

1. **Preserving Existing Columns**: `category_id` and `main_material_id` remain intact
2. **Adding New Columns**: `base_material_id` and `tags` added alongside existing structure
3. **Gradual Transition**: Both systems can coexist during migration period
4. **Mapping Logic**: Business logic determines whether to use legacy or new system

### Migration Script: `20250923_140000_024_materials_restructure.sql`

**Key Operations:**
```sql
-- Create new tables
CREATE TABLE material_tags (...);
CREATE TABLE material_tag_groups (...);
CREATE TABLE base_materials (...);

-- Enhance existing materials table
ALTER TABLE materials
ADD COLUMN IF NOT EXISTS base_material_id BIGINT REFERENCES base_materials(id),
ADD COLUMN IF NOT EXISTS tags JSONB NOT NULL DEFAULT '[]';

-- Backup existing data
CREATE TABLE materials_backup_20250923 AS SELECT * FROM materials;
```

**Safety Features:**
- **Transactional**: All operations in a single transaction
- **IF NOT EXISTS**: Safe column additions
- **Backup Creation**: Complete backup before modifications
- **Rollback Instructions**: Comprehensive rollback procedures
- **Performance Indexes**: Optimized indexing for new columns

## Business Logic Integration

### Material Creation Flow

#### Legacy Flow (Preserved)
```python
# Existing material creation using categories and main materials
material = Material(
    category_id=recycling_category_id,
    main_material_id=plastic_main_material_id,
    name_en="PET Bottle",
    name_th="‡∏Ç‡∏ß‡∏î PET"
)
```

#### New Tag-Based Flow
```python
# New material creation using base materials and tags
material = Material(
    base_material_id=pet_plastic_base_id,
    tags=[(color_group_id, red_tag_id), (quality_group_id, good_tag_id)],
    name_en="Red Good Quality PET Plastic",
    name_th="‡∏û‡∏•‡∏≤‡∏™‡∏ï‡∏¥‡∏Å PET ‡∏™‡∏µ‡πÅ‡∏î‡∏á ‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏î‡∏µ"
)
```

#### Transition Logic
```python
def get_material_hierarchy(material):
    """Determine which system to use for material classification."""
    if material.base_material_id and material.tags:
        # Use new tag-based system
        return build_tag_based_hierarchy(material)
    elif material.category_id and material.main_material_id:
        # Use legacy system
        return build_legacy_hierarchy(material)
    else:
        # Hybrid or incomplete data
        return build_hybrid_hierarchy(material)
```

## SQLAlchemy Model Implementation

### Complete Model Definitions

```python
class MaterialTag(Base, BaseModel):
    """
    Material tags for waste material conditions.

    Can be organization-specific or global tags for categorizing
    waste materials by color, quality, processing state, etc.

    Examples: 'red', 'blue', 'good quality', 'baled', 'contaminated'
    """
    __tablename__ = 'material_tags'

    name = Column(String(255), nullable=False)
    description = Column(Text)
    color = Column(String(7), nullable=False, default='#808080')
    is_global = Column(Boolean, nullable=False, default=False)
    organization_id = Column(BigInteger, ForeignKey('organizations.id'), nullable=True)

    organization = relationship("Organization")

class MaterialTagGroup(Base, BaseModel):
    """
    Groups of similar category material tags.

    Examples:
    - Colors: [red, blue, white, clear]
    - Quality: [good, fair, poor]
    - Processing: [baled, loose, shredded]
    """
    __tablename__ = 'material_tag_groups'

    name = Column(String(255), nullable=False)
    description = Column(Text)
    color = Column(String(7), nullable=False, default='#808080')
    is_global = Column(Boolean, nullable=False, default=False)
    tags = Column(ARRAY(BigInteger), nullable=False, default=[])
    organization_id = Column(BigInteger, ForeignKey('organizations.id'), nullable=True)

    organization = relationship("Organization")

class BaseMaterial(Base, BaseModel):
    """
    Fundamental material types that define the base material properties.

    Can be combined with material tags to create specific material variants.
    Example: "PET Plastic" + [red, good quality, baled] = "Red Good Quality Baled PET Plastic"
    """
    __tablename__ = 'base_materials'

    category_id = Column(BigInteger, ForeignKey('material_categories.id'), nullable=True)
    main_material_id = Column(BigInteger, ForeignKey('main_materials.id'), nullable=True)
    tag_groups = Column(ARRAY(BigInteger), nullable=False, default=[])
    unit_name_th = Column(String(255), nullable=False)
    unit_name_en = Column(String(255), nullable=False)
    unit_weight = Column(DECIMAL(10, 3), nullable=False, default=1)
    color = Column(String(7), nullable=False, default='#808080')
    calc_ghg = Column(DECIMAL(10, 3), nullable=False, default=0)
    name_th = Column(String(255), nullable=False)
    name_en = Column(String(255), nullable=False)

    category = relationship("MaterialCategory")
    main_material = relationship("MainMaterial")
```

## Performance Optimizations

### Indexing Strategy

```sql
-- Material Tags Indexes
CREATE INDEX idx_material_tags_organization ON material_tags(organization_id);
CREATE INDEX idx_material_tags_is_global ON material_tags(is_global);
CREATE INDEX idx_material_tags_is_active ON material_tags(is_active);
CREATE INDEX idx_material_tags_name ON material_tags(name);

-- Material Tag Groups Indexes
CREATE INDEX idx_material_tag_groups_organization ON material_tag_groups(organization_id);
CREATE INDEX idx_material_tag_groups_is_global ON material_tag_groups(is_global);
CREATE INDEX idx_material_tag_groups_is_active ON material_tag_groups(is_active);
CREATE INDEX idx_material_tag_groups_tags ON material_tag_groups USING GIN(tags);

-- Base Materials Indexes
CREATE INDEX idx_base_materials_category ON base_materials(category_id);
CREATE INDEX idx_base_materials_main_material ON base_materials(main_material_id);
CREATE INDEX idx_base_materials_is_active ON base_materials(is_active);
CREATE INDEX idx_base_materials_tag_groups ON base_materials USING GIN(tag_groups);

-- Enhanced Materials Indexes
CREATE INDEX idx_materials_base_material ON materials(base_material_id);
CREATE INDEX idx_materials_tags ON materials USING GIN(tags);
```

### Query Performance

**Tag-based Material Search:**
```sql
-- Find materials with specific tag combinations
SELECT m.*, bm.name_en as base_material_name
FROM materials m
JOIN base_materials bm ON m.base_material_id = bm.id
WHERE m.tags @> '[[3, 8], [1, 2]]'::jsonb  -- Contains quality=good AND processing=baled
AND m.is_active = true;
```

**Tag Group Membership:**
```sql
-- Find all tags in a specific group
SELECT mt.*
FROM material_tags mt
WHERE mt.id = ANY(
    SELECT unnest(tags) FROM material_tag_groups WHERE id = 3
);
```

## API Enhancements

### New Endpoints

#### Material Tags Management
```typescript
// Get organization tags
GET /api/material-tags?organization_id={id}&is_global=true

// Create new tag
POST /api/material-tags
{
  "name": "Premium Quality",
  "description": "High-grade material with minimal contamination",
  "color": "#00ff00",
  "is_global": false,
  "organization_id": 123
}

// Update tag
PUT /api/material-tags/{id}

// Delete tag (soft delete)
DELETE /api/material-tags/{id}
```

#### Material Tag Groups Management
```typescript
// Get tag groups with their tags
GET /api/material-tag-groups?organization_id={id}&include_tags=true

// Create tag group
POST /api/material-tag-groups
{
  "name": "Quality Levels",
  "description": "Material quality classification",
  "color": "#0066cc",
  "tags": [1, 2, 3, 4],  // Array of tag IDs
  "is_global": false,
  "organization_id": 123
}
```

#### Base Materials Management
```typescript
// Get base materials with applicable tag groups
GET /api/base-materials?include_tag_groups=true

// Create base material
POST /api/base-materials
{
  "category_id": 1,
  "main_material_id": 5,
  "tag_groups": [1, 2, 3],  // Applicable tag group IDs
  "name_en": "PET Plastic",
  "name_th": "‡∏û‡∏•‡∏≤‡∏™‡∏ï‡∏¥‡∏Å PET",
  "unit_name_en": "Kilogram",
  "unit_name_th": "‡∏Å‡∏¥‡πÇ‡∏•‡∏Å‡∏£‡∏±‡∏°",
  "unit_weight": 1.0,
  "calc_ghg": 1.031
}
```

#### Enhanced Materials API
```typescript
// Get materials with tag resolution
GET /api/materials?resolve_tags=true&base_material_id={id}

// Create material with tags
POST /api/materials
{
  "base_material_id": 1,
  "tags": [[3, 8], [1, 2], [4, 1]],  // [(group_id, tag_id), ...]
  "name_en": "Red Good Quality Baled PET Plastic",
  "name_th": "‡∏û‡∏•‡∏≤‡∏™‡∏ï‡∏¥‡∏Å PET ‡∏™‡∏µ‡πÅ‡∏î‡∏á ‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏î‡∏µ ‡∏≠‡∏±‡∏î‡∏Å‡πâ‡∏≠‡∏ô",
  // ... other material properties
}
```

## Frontend Integration

### UI/UX Enhancements

#### Tag-Based Material Creation
```typescript
interface MaterialCreationFlow {
  // Step 1: Select base material
  baseMaterial: BaseMaterial;

  // Step 2: Configure tags for each applicable group
  tagSelections: {
    [tagGroupId: string]: {
      groupName: string;
      selectedTagId: string;
      selectedTagName: string;
    }
  };

  // Step 3: Auto-generate or customize material name
  generatedName: string;
  customName?: string;
}
```

#### Visual Components
```typescript
// Tag color coding in material displays
<MaterialCard
  material={material}
  showTags={true}
  tagColorMode="group"  // 'group' | 'individual' | 'none'
/>

// Tag group selector component
<TagGroupSelector
  baseaterial={selectedBaseMaterial}
  onTagSelection={(groupId, tagId) => handleTagSelection(groupId, tagId)}
  required={true}
/>

// Material search with tag filters
<MaterialSearch
  filters={{
    baseMaterialId: number,
    tagCombinations: [[groupId, tagId], ...],
    organizations: [orgId, ...],
    categories: [catId, ...]
  }}
/>
```

### Tag Management Interface

#### Organization Tag Administration
```typescript
interface TagManagementInterface {
  // Global vs Organization toggle
  scope: 'global' | 'organization';

  // Tag CRUD operations
  createTag: (tag: CreateTagRequest) => Promise<MaterialTag>;
  updateTag: (id: string, updates: UpdateTagRequest) => Promise<MaterialTag>;
  deleteTag: (id: string) => Promise<void>;

  // Tag group management
  createTagGroup: (group: CreateTagGroupRequest) => Promise<MaterialTagGroup>;
  updateTagGroup: (id: string, updates: UpdateTagGroupRequest) => Promise<MaterialTagGroup>;
  assignTagsToGroup: (groupId: string, tagIds: string[]) => Promise<void>;
}
```

## Testing Strategy

### Unit Testing

#### Model Validation Tests
```python
def test_material_tag_constraints():
    """Test material tag global/organization constraints."""
    # Global tag should not have organization_id
    global_tag = MaterialTag(name="Global Red", is_global=True, organization_id=None)
    assert global_tag.validate() == []

    # Org-specific tag should have organization_id
    org_tag = MaterialTag(name="Org Red", is_global=False, organization_id=123)
    assert org_tag.validate() == []

    # Invalid: global tag with organization_id
    invalid_tag = MaterialTag(name="Invalid", is_global=True, organization_id=123)
    assert len(invalid_tag.validate()) > 0

def test_material_tag_combinations():
    """Test valid tag combinations in materials."""
    # Valid tag combination
    material = Material(
        base_material_id=1,
        tags=[[3, 8], [1, 2]],  # Valid group-tag combinations
        name_en="Test Material"
    )
    assert material.validate_tag_combinations() == []

    # Invalid: tag not in specified group
    invalid_material = Material(
        base_material_id=1,
        tags=[[3, 999]],  # Tag 999 not in group 3
        name_en="Invalid Material"
    )
    assert len(invalid_material.validate_tag_combinations()) > 0
```

#### Business Logic Tests
```python
def test_material_hierarchy_resolution():
    """Test material hierarchy resolution logic."""
    # Test new tag-based system
    tag_based_material = create_tag_based_material()
    hierarchy = get_material_hierarchy(tag_based_material)
    assert hierarchy.system == 'tag_based'
    assert len(hierarchy.tags) > 0

    # Test legacy system
    legacy_material = create_legacy_material()
    hierarchy = get_material_hierarchy(legacy_material)
    assert hierarchy.system == 'legacy'
    assert hierarchy.category is not None

    # Test hybrid system
    hybrid_material = create_hybrid_material()
    hierarchy = get_material_hierarchy(hybrid_material)
    assert hierarchy.system == 'hybrid'
```

### Integration Testing

#### API Endpoint Tests
```python
def test_material_creation_with_tags():
    """Test complete material creation flow with tags."""
    # Create base material
    base_material = create_base_material_via_api()

    # Create tags and groups
    color_group = create_tag_group_via_api("Colors")
    red_tag = create_tag_via_api("Red", color_group.id)

    # Create material with tags
    material_data = {
        "base_material_id": base_material.id,
        "tags": [[color_group.id, red_tag.id]],
        "name_en": "Red PET Plastic"
    }

    response = client.post("/api/materials", json=material_data)
    assert response.status_code == 201

    # Verify tag resolution
    material = response.json()["data"]
    assert len(material["resolved_tags"]) == 1
    assert material["resolved_tags"][0]["tag_name"] == "Red"

def test_tag_group_management():
    """Test tag group CRUD operations."""
    # Create tag group
    group_data = {
        "name": "Test Group",
        "description": "Test description",
        "is_global": False,
        "organization_id": 123
    }

    response = client.post("/api/material-tag-groups", json=group_data)
    assert response.status_code == 201
    group = response.json()["data"]

    # Add tags to group
    tag1 = create_tag_via_api("Tag 1")
    tag2 = create_tag_via_api("Tag 2")

    update_data = {"tags": [tag1.id, tag2.id]}
    response = client.put(f"/api/material-tag-groups/{group['id']}", json=update_data)
    assert response.status_code == 200

    # Verify tags in group
    response = client.get(f"/api/material-tag-groups/{group['id']}?include_tags=true")
    group_with_tags = response.json()["data"]
    assert len(group_with_tags["tag_details"]) == 2
```

### Performance Testing

#### Query Performance Tests
```python
def test_tag_based_material_search_performance():
    """Test performance of tag-based material searches."""
    # Create test data
    create_test_materials_with_tags(count=10000)

    # Test JSONB containment query performance
    start_time = time.time()

    materials = session.query(Material).filter(
        Material.tags.op('@>')('[[3, 8]]')  # Contains quality=good
    ).limit(100).all()

    query_time = time.time() - start_time
    assert query_time < 0.1  # Should complete within 100ms
    assert len(materials) > 0

def test_tag_group_array_search_performance():
    """Test performance of array-based tag group searches."""
    # Create test tag groups
    create_test_tag_groups(count=1000)

    start_time = time.time()

    groups = session.query(MaterialTagGroup).filter(
        MaterialTagGroup.tags.any(specific_tag_id)
    ).all()

    query_time = time.time() - start_time
    assert query_time < 0.05  # Should complete within 50ms
```

## Monitoring and Analytics

### Performance Metrics

#### Database Performance
```sql
-- Monitor index usage for new tables
SELECT
    schemaname, tablename, indexname, idx_scan, idx_tup_read
FROM pg_stat_user_indexes
WHERE tablename IN ('material_tags', 'material_tag_groups', 'base_materials')
ORDER BY idx_scan DESC;

-- Monitor JSONB query performance
SELECT
    query, calls, total_time, mean_time, rows
FROM pg_stat_statements
WHERE query LIKE '%tags @>%'
ORDER BY total_time DESC;
```

#### Business Metrics
```sql
-- Tag usage analytics
SELECT
    mt.name,
    COUNT(*) as usage_count,
    AVG(m.unit_weight) as avg_weight
FROM materials m
JOIN LATERAL jsonb_array_elements(m.tags) AS tag_tuple ON true
JOIN material_tags mt ON mt.id = (tag_tuple->>1)::bigint
WHERE m.is_active = true
GROUP BY mt.id, mt.name
ORDER BY usage_count DESC;

-- Base material popularity
SELECT
    bm.name_en,
    COUNT(*) as material_count,
    SUM(m.unit_weight) as total_weight
FROM materials m
JOIN base_materials bm ON m.base_material_id = bm.id
WHERE m.is_active = true
GROUP BY bm.id, bm.name_en
ORDER BY material_count DESC;
```

## Security Considerations

### Data Validation

#### Tag Validation Rules
```python
class MaterialTagValidator:
    @staticmethod
    def validate_global_organization_constraint(tag: MaterialTag) -> List[str]:
        """Validate global/organization constraint."""
        errors = []

        if tag.is_global and tag.organization_id is not None:
            errors.append("Global tags cannot have organization_id")

        if not tag.is_global and tag.organization_id is None:
            errors.append("Organization-specific tags must have organization_id")

        return errors

    @staticmethod
    def validate_color_format(color: str) -> List[str]:
        """Validate hex color format."""
        if not re.match(r'^#[0-9A-Fa-f]{6}$', color):
            return ["Color must be a valid hex color code (e.g., #FF0000)"]
        return []

class MaterialValidator:
    @staticmethod
    def validate_tag_combinations(material: Material) -> List[str]:
        """Validate that tags belong to their specified groups."""
        errors = []

        for group_id, tag_id in material.tags:
            # Verify tag belongs to group
            tag_group = session.query(MaterialTagGroup).get(group_id)
            if tag_group and tag_id not in tag_group.tags:
                errors.append(f"Tag {tag_id} does not belong to group {group_id}")

        return errors
```

#### Access Control
```python
class MaterialTagPermissions:
    @staticmethod
    def can_create_global_tag(user: User) -> bool:
        """Check if user can create global tags."""
        return user.has_system_permission('create_global_material_tags')

    @staticmethod
    def can_modify_organization_tags(user: User, organization_id: int) -> bool:
        """Check if user can modify organization-specific tags."""
        return (
            user.organization_id == organization_id and
            user.has_organization_permission('manage_material_tags')
        )

    @staticmethod
    def can_access_tag(user: User, tag: MaterialTag) -> bool:
        """Check if user can access a specific tag."""
        if tag.is_global:
            return True
        return user.organization_id == tag.organization_id
```

## Rollback Procedures

### Complete Rollback Instructions

```sql
-- ROLLBACK INSTRUCTIONS FOR MIGRATION 20250923_140000_024
--
-- WARNING: This will remove all new tables and columns
-- Make sure to backup any data you want to preserve
--
-- Step 1: Remove new columns from materials table
ALTER TABLE materials DROP COLUMN IF EXISTS base_material_id;
ALTER TABLE materials DROP COLUMN IF EXISTS tags;

-- Step 2: Drop new tables (in correct order due to foreign keys)
DROP TABLE IF EXISTS base_materials;
DROP TABLE IF EXISTS material_tag_groups;
DROP TABLE IF EXISTS material_tags;

-- Step 3: Restore original materials data if needed
-- (Use materials_backup_20250923 table created during migration)
--
-- Option A: Complete restore (WARNING: loses any new data)
-- DROP TABLE materials;
-- ALTER TABLE materials_backup_20250923 RENAME TO materials;
--
-- Option B: Selective restore of specific columns/rows
-- UPDATE materials SET column_name = backup.column_name
-- FROM materials_backup_20250923 backup
-- WHERE materials.id = backup.id;

-- Step 4: Recreate original indexes if needed
-- (Check existing indexes first with \d materials)
```

### Rollback Testing
```python
def test_rollback_procedure():
    """Test that rollback procedure works correctly."""
    # Apply migration
    apply_migration("20250923_140000_024_materials_restructure.sql")

    # Create some test data
    create_test_tag_data()

    # Backup test data
    backup_new_table_data()

    # Apply rollback
    apply_rollback_script()

    # Verify rollback
    assert not table_exists("material_tags")
    assert not table_exists("material_tag_groups")
    assert not table_exists("base_materials")
    assert not column_exists("materials", "base_material_id")
    assert not column_exists("materials", "tags")

    # Verify original data integrity
    assert verify_original_materials_data()
```

## Future Enhancements

### Planned Features

#### Advanced Tag Relationships
```sql
-- Future: Tag dependencies and exclusions
CREATE TABLE material_tag_relationships (
    id BIGSERIAL PRIMARY KEY,
    source_tag_id BIGINT REFERENCES material_tags(id),
    target_tag_id BIGINT REFERENCES material_tags(id),
    relationship_type VARCHAR(50), -- 'requires', 'excludes', 'implies'
    created_date TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

#### Material Templates
```sql
-- Future: Predefined material templates for industries
CREATE TABLE material_templates (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    industry_type VARCHAR(100),
    base_material_id BIGINT REFERENCES base_materials(id),
    default_tags JSONB,
    created_date TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

#### Tag Analytics
```python
# Future: Advanced tag analytics and recommendations
class TagAnalytics:
    def get_popular_tag_combinations(self, organization_id: int) -> List[TagCombination]:
        """Get most frequently used tag combinations."""
        pass

    def recommend_tags_for_base_material(self, base_material_id: int) -> List[MaterialTag]:
        """Recommend tags based on similar materials."""
        pass

    def analyze_tag_performance(self, tag_id: int) -> TagPerformanceMetrics:
        """Analyze performance metrics for specific tags."""
        pass
```

## Summary

### Key Benefits of v0.0.2 Restructure

‚úÖ **Flexible Material Classification**: Tag-based system supports complex material conditions
‚úÖ **Backward Compatibility**: Existing category/main material system preserved
‚úÖ **Organization Scoping**: Tags can be global or organization-specific
‚úÖ **Performance Optimized**: GIN indexing for array and JSONB operations
‚úÖ **Scalable Architecture**: Supports unlimited tag combinations
‚úÖ **Visual Organization**: Color coding for better UI/UX
‚úÖ **Environmental Intelligence**: GHG calculation factors maintained
‚úÖ **Multi-language Support**: Thai and English naming throughout
‚úÖ **Audit Trail**: Complete BaseModel inheritance for change tracking
‚úÖ **Migration Safety**: Comprehensive backup and rollback procedures

### System Capabilities

- **Material Variants**: Create unlimited material variants through tag combinations
- **Dynamic Classification**: Real-time material classification based on tags
- **Organization Customization**: Each organization can define custom tags and groups
- **Reporting Flexibility**: Enhanced reporting with tag-based filtering
- **API Extensibility**: Rich API endpoints for all tag operations
- **Performance Scaling**: Optimized for large-scale material catalogs

### Implementation Status

**Database Schema**: ‚úÖ Complete with migration script
**SQLAlchemy Models**: ‚úÖ Complete with relationships
**API Endpoints**: üîÑ Design complete, implementation pending
**Frontend Integration**: üìã Specifications ready for development
**Testing Strategy**: üìã Comprehensive test plan defined
**Documentation**: ‚úÖ Complete regulatory framework established

### Next Steps

1. **API Implementation**: Develop new endpoints for tag management
2. **Frontend Development**: Build tag-based material creation UI
3. **Data Migration**: Plan transition from legacy to new system
4. **Testing Execution**: Implement and run comprehensive test suites
5. **Performance Tuning**: Optimize queries and indexing strategies
6. **User Training**: Develop documentation and training materials

**Migration Status:** Ready for deployment with comprehensive safety measures
**Risk Level:** Low - Backward compatible with complete rollback procedures
**Business Impact:** High - Enables flexible material management for all organizations

---

**Last Updated:** September 23, 2025
**Version:** v0.0.2
**Status:** IMPLEMENTATION READY
**Migration File:** `20250923_140000_024_materials_restructure.sql`
**Model Updates:** `backend/GEPPPlatform/models/cores/references.py`